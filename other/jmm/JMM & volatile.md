## 一、JMM

### 1.1 什么是JMM

> ​		java内存模型（**J**ava **M**emory **M**odel）是一种抽象的概念，并不真实存在，他描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组）的访问方式。JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有数据，而java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量拷贝副本，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成。

### 1.2 JMM 不同于JVM内存区域模型

> ​		JMM与JVM内存区域的划分是不同的概念层次，更恰当的说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕**原子性、有序性、可见性**展开的 。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中内存属于共享数据区域，从某种程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。

**线程、工作内存、主内存工作交互图（基于JMM规范）：**

![image-20210329222528080](.\img\image-20210329222528080.png)

### 1.3 主内存

> ​		主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该**实例对象是成员变量还是方法中的本地变量（也称局部变量）**，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题。

### 1.4 工作内存

​		主要存储当前方法的所有本地变量信息（工作内存中存储着主内存中的变量拷贝副本），每个线程只能访问自己的工作内存，即线程中的本地变量对其他线程不可见的，就算是两个线程执行的是同一段代码，他们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括字节码行号指示器，相关native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储工作内存的数据不存在线程安全问题。

​		根据JVM虚拟机规范主内存与工作内存的数据存储类型以及操作方式，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的栈帧中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的栈帧中，而对象实例将存储在主内存（共享数据区域，堆）中。但对于实例对象的成员变量，不管他是基本数据类型或者包装类型（Integer，Double）还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才能刷新到主内存

​	模型如下图

![image-20210331215912195](.\img\image-20210331215912195.png)

### 1.5  java内存模型与硬件内存架构的关系

​		通过对前面的硬件内存架构，java内存模型以及java多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上执行，但java内存模型和硬件内存架构并不完全一致。对与硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存（线程私有数据区域）和主内存（堆内存）之分，也就是说java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体来说，java内存模型和计算机硬件内存结构是一个相互交叉的关系，是一种抽象概念划分和真是物理硬件的交叉（注意对于java内存区域划分也是同样的道理）

![image-20210331220519689](.\img\image-20210331220519689.png)

### 1.6 JMM 存在的必要性

​		在明白了java内存区域划分，硬件内存结构，java多线程的实现原理与java内存模型的具体关系后，接下来谈谈java内存模型存在的必要性。由于jvm运行程序的实体是线程，而每个线程创建时jvm都会为其创建一个工作内存（有些地方称为栈空间），用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，**主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间**，**然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题**。

​		假设主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作，A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2？还是更新前的值1呢？答案是，不确定，即B线程有可能读到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内存，而对于线程B也是类似的，这样就有可能造成主内存和工作内存数据存在一致性问题，加入A线程修改完后正在讲数据写回主内存，而B线程此时正在读取主内存，即x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但是如果A线程已将x=2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x=2，但到底是那种情况先发生呢？

如以下示例图所示：

![image-20210331221853479](.\img\image-20210331221853479.png)